# GraphQL

- 프론트엔드와 백엔드가 효율적으로 커뮤니케이션 하도록 한다.
  - 스키마(Schema)를 통해 데이터 API의 기능범위를 파악할 수 있다.
  - 이는, 항상 최신의 문서를 제공하는 것과 같다.
- 프론트엔드와 백엔드에서 사용한다. 백엔드의 경우 다양한 언어를 지원한다.
- Graph는 현실 세계의 데이터를 표현하는 가장 적합한 방법이 그래프라는 사실에서 착안
- 선언적
- 프론트엔드와 백엔드 프레임워크, 기술 스택, 데이터베이스 등 어떤 것에도 종속적이지 않다.
  - 전송 채널이나 데이터 형식에도 제한이 없다.
- 단일 요청으로 필요한 데이터를 모두 가져올 수 없는 underfetching 문제 해결
  - 기존 REST API에서 원하는 데이터를 얻으려면 다중 요청으로 Client에서 데이터를 가공해서 사용해야 했었다.
  - 처리 성능, 메모리, 네트워크 등에 제약이 있는 모바일 장치에서는 문제가 된다.
- 단일 요청에 불필요한 데이터도 가져오는 overfetching 문제 해결
- Client가 데이터 요청에 유연하게 대처할 수 있다.
  - REST API의 경우 Client의 데이터 사용에 따라 새로운 엔드포인트가 추가될 수 있다.
  - 또는, Client에서 데이터를 조합하기 위해 필요한 요청과 데이터의 의미를 파악해야 한다.
  - 반면, GraphQL은 Client가 필요한 데이터 조합을 만들어 요청할 수 있다. 이는 뷰와 데이터간 관계가 명확해진다.
- 간단한 버전 관리
  - 모바일 앱은 기기에 설치되므로 API의 버전을 제어하기 쉽지 않다.

백엔드에는 GraphQL 기반의 런타임이 필요하다.  
런타임은 API를 통해 제공될 데이터 구조를 관리하는데 이 구조를 스키마(Schema)라고 한다.

# GraphQL의 문제점

- 데이터 요청에 제약이 없어서 한번에 아주 많은 데이터를 요청할 수 있다. 이는, DDOS 공격에 노출된다.
  - 이는, 여러 방법으로 해결할 수 있다.
    - 데이터 양 제한
    - 타임아웃
    - GraphQL 보다 낮은 계층에서 강제적으로 처리량을 제어
    - 내부적으로 GraphQL을 사용한다면 쿼리에 대한 allow-list를 만들어 관리
- 캐시와 최적화
  - REST API는 URL 자체를 캐시키로 사용할 수 있다.
  - GraphQL은 쿼리 텍스트를 키로 사용할 수 있지만 비효율성과 데이터 일관성 문제를 초래할 수 있다.
  - Graph Cache를 사용할 수 있다.
    - 응답을 평면 구조의 레코드 집합으로 일반화한 후 각 레코드에 전역 고유 ID를 부여하면 전체 응답이 아닌 개별 레코드를 캐싱할 수 있다.
- 학습 곡선
